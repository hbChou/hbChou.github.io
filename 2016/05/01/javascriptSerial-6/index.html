<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>你所不知道的javascript之对象和继承 | hbChou</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="接下来让我们看看在javascript中如何实现面向对象编程的。javascript中的面向对象涉及很多东西，包括原型，属性描述符等等。



创建对象
工厂方式
构造函数模式
原型模式
组合使用构造函数模式和原型模式


继承
原型链
借用构造函数
组合继承
原型式继承


对象上的属性
有关对象的其他方法




创建对象首先需要了解javascript都有哪些方法可以用来创建对象

工厂方式">
<meta property="og:type" content="article">
<meta property="og:title" content="你所不知道的javascript之对象和继承">
<meta property="og:url" content="http://yoursite.com/2016/05/01/javascriptSerial-6/index.html">
<meta property="og:site_name" content="hbChou">
<meta property="og:description" content="接下来让我们看看在javascript中如何实现面向对象编程的。javascript中的面向对象涉及很多东西，包括原型，属性描述符等等。



创建对象
工厂方式
构造函数模式
原型模式
组合使用构造函数模式和原型模式


继承
原型链
借用构造函数
组合继承
原型式继承


对象上的属性
有关对象的其他方法




创建对象首先需要了解javascript都有哪些方法可以用来创建对象

工厂方式">
<meta property="og:updated_time" content="2016-05-08T03:24:26.521Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="你所不知道的javascript之对象和继承">
<meta name="twitter:description" content="接下来让我们看看在javascript中如何实现面向对象编程的。javascript中的面向对象涉及很多东西，包括原型，属性描述符等等。



创建对象
工厂方式
构造函数模式
原型模式
组合使用构造函数模式和原型模式


继承
原型链
借用构造函数
组合继承
原型式继承


对象上的属性
有关对象的其他方法




创建对象首先需要了解javascript都有哪些方法可以用来创建对象

工厂方式">
  
    <link rel="alternative" href="/atom.xml" title="hbChou" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/image.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">hbChou</a></h1>
		</hgroup>

		
		<p class="header-subtitle">每天都要有所收获</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
						<li>Über</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/hbChou" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/u/3301672992?s=6cm7D0&is_all=1" title="weibo">weibo</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/zhou-hai-bin-63" title="zhihu">zhihu</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/ES6/" style="font-size: 10px;">ES6</a> <a href="/tags/HTML5/" style="font-size: 10px;">HTML5</a> <a href="/tags/javascript/" style="font-size: 20px;">javascript</a> <a href="/tags/前端安全与优化/" style="font-size: 10px;">前端安全与优化</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://segmentfault.com/">segmentfault社区</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我就是我，是颜色不一样的烟火</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">hbChou</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/image.png" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">hbChou</h1>
			</hgroup>
			
			<p class="header-subtitle">每天都要有所收获</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/hbChou" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/u/3301672992?s=6cm7D0&is_all=1" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/zhou-hai-bin-63" title="zhihu">zhihu</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-javascriptSerial-6" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/01/javascriptSerial-6/" class="article-date">
  	<time datetime="2016-05-01T06:55:44.000Z" itemprop="datePublished">2016-05-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      你所不知道的javascript之对象和继承
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>接下来让我们看看在<code>javascript</code>中如何实现面向对象编程的。<code>javascript</code>中的面向对象涉及很多东西，包括原型，属性描述符等等。</p>
<hr>
<!-- MarkdownTOC -->
<ul>
<li><a href="#创建对象"><strong>创建对象</strong></a><ul>
<li><a href="#工厂方式">工厂方式</a></li>
<li><a href="#构造函数模式">构造函数模式</a></li>
<li><a href="#原型模式">原型模式</a></li>
<li><a href="#组合使用构造函数模式和原型模式">组合使用构造函数模式和原型模式</a></li>
</ul>
</li>
<li><a href="#继承"><strong>继承</strong></a><ul>
<li><a href="#原型链">原型链</a></li>
<li><a href="#借用构造函数">借用构造函数</a></li>
<li><a href="#组合继承">组合继承</a></li>
<li><a href="#原型式继承">原型式继承</a></li>
</ul>
</li>
<li><a href="#对象上的属性"><strong>对象上的属性</strong></a></li>
<li><a href="#有关对象的其他方法"><strong>有关对象的其他方法</strong></a></li>
</ul>
<!-- /MarkdownTOC -->
<hr>
<p><a name="创建对象"></a></p>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a><strong>创建对象</strong></h2><p>首先需要了解<code>javascript</code>都有哪些方法可以用来创建对象</p>
<p><a name="工厂方式"></a></p>
<h3 id="工厂方式"><a href="#工厂方式" class="headerlink" title="工厂方式"></a>工厂方式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hello!"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> male = createPerson(<span class="string">"hb"</span>);</span><br><span class="line"><span class="keyword">var</span> female = createPerson(<span class="string">"gp"</span>);</span><br></pre></td></tr></table></figure>
<p>优点：通过工厂模式可以很方便地创建出不同的对象<br>缺点：不能识别出创建出来的对象是属于哪种类型的</p>
<p><a name="构造函数模式"></a></p>
<h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hello!"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> male = <span class="keyword">new</span> Person(<span class="string">"hb"</span>);</span><br><span class="line"><span class="keyword">var</span> female = <span class="keyword">new</span> Person(<span class="string">"gp"</span>);</span><br></pre></td></tr></table></figure>
<p>使用构造函数模式需要通过<code>new</code>关键字来创建对象。创建对象的过程：</p>
<ul>
<li>在构造函数内部创建一个空对象</li>
<li>将该空对象赋值给构造函数内部的<code>this</code>指针，执行构造函数中的代码</li>
<li>在没有显式返回某个对象的时候返回<code>this</code>指向的对象</li>
</ul>
<p>构造函数模式的优点：可以确定创建的对象实例属于哪个类型</p>
<ul>
<li><p>使用<code>instanceof</code>操作符：用于检测某个对象是否为指定构造函数的实例，根据需要判断类型的对象的原型链上是否存在给定的构造函数的原型对象（即构造函数的<code>prototype</code>属性）返回一个布尔值。存在的问题是在不同<code>iframe</code>和<code>window</code>之间检测时会失效。<code>instanceof</code>对前后两个参数都有要求，一般前面的参数为对象，后面的参数为构造函数名称。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"hello"</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>访问对象上的<code>constructor</code>属性：该属性实际位于构造函数的原型对象上。</p>
</li>
</ul>
<p>缺点：同一类型的对象不能共享具有相同功能的方法</p>
<p><a name="原型模式"></a></p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"hb"</span>;</span><br><span class="line">Person.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"hello!"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> male = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>
<p>该模式的主要思想是对象的一些共有方法放到构造函数的原型对象上，实现共享。<code>javascript</code>中也提供了一些方法用于判断实例和原型之间的关系：（对象可以直接调用的方法比如<code>isPrototypeOf</code>，<code>hasOwnProperty</code>等等都位于<code>Object.prototype</code>对象上）</p>
<ul>
<li><code>protoObj.isPrototypeOf(obj)</code>：判断对象obj1是否为obj的原型（并不一定非得是直接原型，可以是原型链上的其他原型对象），返回一个布尔值</li>
<li><code>Object.getPrototypeOf(obj)</code>：获取某个对象的原型</li>
</ul>
<p>在实例上直接添加的属性会覆盖原型上的同名属性，通过<code>delete</code>操作符可以删除指定的<strong>实例属性</strong>（即使实例上不存在该属性，也不会删除原型上的属性），从而恢复对原型对象上的属性访问（只能通过这种方式恢复，直接将实例属性赋值为<code>undefined</code>是不起作用的）。</p>
<ul>
<li><code>obj.hasOwnProperty(attr)</code>：用于判断对象是否具有实例属性<code>attr</code>，返回一个布尔值。</li>
<li><p><code>in</code>操作符：判断某个对象或者它的原型链上是否存在指定的属性（<strong>不一定得是可枚举的属性</strong>）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"toString"</span> <span class="keyword">in</span> male); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Object.keys(obj)</code>：该方法返回一个包含所有可枚举的<strong>实例属性</strong>p的字符串数组</p>
</li>
<li><code>Object.getOwnPropertyNames(obj)</code>：该方法返回一个包含所有实例属性的字符串数组</li>
</ul>
<p><strong>直接重写原型对象会发生什么？？</strong><br>直接重写原型对象需要特别注意的一点是需要自觉修正原型对象的<code>constructor</code>属性，修改构造函数的整个<code>prototype</code>属性（即让<code>prototype</code>属性指向另一个对象）对已经创建好的对象实例没有影响，这些对象实例访问到的还是修改以前的原型对象。而对于以后创建的实例对象，<code>prototype</code> 属性则发生了改变。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"hb"</span>;</span><br><span class="line">Person.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> male = <span class="keyword">new</span> Person();</span><br><span class="line">Person.prototype =  &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: Person,</span><br><span class="line">  name: "gp",</span><br><span class="line">  say: function () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"bye"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> female = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(male.name + <span class="string">" says "</span> + male.say()); <span class="comment">// hb says hello</span></span><br><span class="line"><span class="built_in">console</span>.log(female.name + <span class="string">" says "</span> + female.say()); <span class="comment">// gp says bye</span></span><br></pre></td></tr></table></figure></p>
<p>原型模式的优点：可以实现一些属性和方法在不同的对象之间进行共享<br>缺点：当不同的对象共享了诸如数组这样的对象时，如果其中某个对象对其进行修改，势必会对其他对象产生影响。</p>
<p><a name="组合使用构造函数模式和原型模式"></a></p>
<h3 id="组合使用构造函数模式和原型模式"><a href="#组合使用构造函数模式和原型模式" class="headerlink" title="组合使用构造函数模式和原型模式"></a>组合使用构造函数模式和原型模式</h3><p>利用构造函数模式可以实现每个对象上的实例属性，即为个性，而原型模式可以实现一些属性和方法的共享，此乃共性。两者优势互补，相得益彰。</p>
<p><a name="继承"></a></p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a><strong>继承</strong></h2><p><a name="原型链"></a></p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>可以通过原型链来实现继承。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"Animal"</span>;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.eat = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">" eats"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bird</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.color = <span class="string">"blue"</span>;</span><br><span class="line">&#125;</span><br><span class="line">Bird.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line"><span class="comment">// 注意此处重写了原型对象，原本的Bird构造函数的</span></span><br><span class="line"><span class="comment">// 原型对象上的constructor属性丢失</span></span><br><span class="line">Bird.prototype.fly = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.color + <span class="string">" bird flys."</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bird = <span class="keyword">new</span> Bird();</span><br><span class="line">bird.eat(); <span class="comment">// "Animal eats."</span></span><br><span class="line">bird.fly(); <span class="comment">// "blue bird flys."</span></span><br><span class="line"><span class="built_in">console</span>.log(bird.constructor); <span class="comment">// Animal</span></span><br></pre></td></tr></table></figure></p>
<p>单独使用原型链也会存在一些问题：</p>
<ul>
<li>原本定义在父类构造函数中的实例属性和方法通过原型链会变成子类构造函数的原型对象上的用于子类对象共享的属性和方法，这就限制了父类构造函数的实例属性不能引用诸如数组这些对象。</li>
<li>在通过父类构造函数构造子类构造函数的原型对象时，稍微修改父类对象（即子类构造函数的原型对象）的属性和方法都会直接影响所有子类对象。</li>
</ul>
<p><a name="借用构造函数"></a></p>
<h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><p>基本思想是在子类构造函数中调用父类构造函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  Super.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> Child(<span class="string">"javascript"</span>);</span><br><span class="line">obj1.colors.push(<span class="string">"yellow"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj1.colors); <span class="comment">// ["red", "green", "blue", "yellow"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="built_in">console</span>.log(obj2.colors); <span class="comment">// ["red", "green", "blue"]</span></span><br></pre></td></tr></table></figure></p>
<p>从上面的栗子可以看出，借用构造函数这种方法可以有效解决原型链中的第一个问题。同时，在创建子类对象时也可以根据不同对象的需求给实例自身添加属性。本质上，这种方法主要还是利用构造函数创建对象，跟前面的构造函数模式存在相同的问题：无法实现函数复用。</p>
<p><a name="组合继承"></a></p>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>充分利用前面两种方法的优势。</p>
<p><a name="原型式继承"></a></p>
<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>基本思想就是在一个函数中以给定的对象作为原型，创建一个空对象并返回。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：</strong>从本质上讲，<code>createObject</code>函数对传入其中的对象进行了一次浅复制。<br><code>ECMAScript 5</code>中提供了<code>Object.create(obj)</code>方法来实现原型式继承。该方法接受两个参数：一个充当原型的对象以及一个可选的为新对象定义额外属性的对象。<code>Object.create()</code>函数传入的第二个参数和<code>Object.defineProperty()</code>定义属性描述符的格式类似。如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(&#123;name: <span class="string">"hb"</span>&#125;, &#123;</span><br><span class="line">  age: &#123;</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    value: <span class="number">27</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><a name="对象上的属性"></a></p>
<h2 id="对象上的属性"><a href="#对象上的属性" class="headerlink" title="对象上的属性"></a><strong>对象上的属性</strong></h2><p>对象上的属性分两种：数据属性和访问器属性</p>
<ul>
<li>数据属性<br>数据属性有四个描述其行为的特性：<ul>
<li><code>[[configurable]]</code> 表示能否通过<code>delete</code>删除属性，能否修改该属性的特性，或者能否把属性修改为访问器属性。</li>
<li><code>[[enumerable]]</code> 表示能否通过for-in循环遍历到该属性。</li>
<li><code>[[writable]]</code> 表示能否修改该属性的值</li>
<li><code>[[value]]</code> 包含这个属性的数据值</li>
</ul>
</li>
</ul>
<p>要修改对象属性的特性，可以使用<code>Object.defineProperty()</code>方法。该方法接收三个参数：属性所在的对象，属性名称和一个描述符对象。如果需要同时定义多个属性，可以使用<code>Object.defineProperties(obj,{attr1:descriptor1,attr2:descriptor2,...})</code>方法，接收的参数略有不同。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> male = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(male, <span class="string">"name"</span>, &#123;</span><br><span class="line">  value: <span class="string">"hb"</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(male.name); <span class="comment">// "hb"</span></span><br><span class="line">male.name = <span class="string">"gp"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(male.name); <span class="comment">// "hb"</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(male, <span class="string">"name"</span>, &#123;</span><br><span class="line">  writable: <span class="literal">true</span></span><br><span class="line">&#125;); <span class="comment">// 报错，当第一次将configurable设置为false，就不能再重复定义同样属性</span></span><br></pre></td></tr></table></figure></p>
<p><strong>注意：</strong>在调用<code>Object.defineProperty()</code>方法时，如果不明确指定，<code>configurable</code>、<code>enumerable</code>和<code>writable</code>特性的默认值为<code>false</code>。</p>
<ul>
<li>访问器属性<br>访问器属性不包含数据值。它有如下四个特性：<ul>
<li><code>[[configurable]]</code> 表示能否通过<code>delete</code>删除属性，能否修改该属性的特性，或者能否把属性修改为数据属性。</li>
<li><code>[[enumerable]]</code> 表示能否通过 <code>for-in</code> 循环遍历到该属性。</li>
<li><code>[[get]]</code> 指定在读取属性时调用的函数。默认值是undefined。</li>
<li><code>[[set]]</code> 指定在写入属性时调用的函数。</li>
</ul>
</li>
</ul>
<p>如果对象上的某个属性定义了<code>get</code>或者<code>set</code>特性，则会调用对象上的<code>get</code>或者<code>set</code>特性对应的函数进行数值的获取或者赋值（这通常通过中间变量完成），而不会直接获取或修改对象的属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;name: <span class="string">"haibin"</span>, $age: <span class="number">22</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">"age"</span>, &#123;</span><br><span class="line">  get:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$age;</span><br><span class="line">  &#125;,</span><br><span class="line">  set:<span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.$age = arg;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj.age); <span class="comment">// 22</span></span><br><span class="line">obj.age = <span class="number">24</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">//&#123;name: "haibin", $age: 24&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.age); <span class="comment">//24</span></span><br></pre></td></tr></table></figure></p>
<p>另外我们在定义对象字面量时，也可以定义属性的<code>get</code>和<code>set</code>方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> man = &#123;</span><br><span class="line">  _age: <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="number">1984</span>,</span><br><span class="line">  get age()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._age;</span><br><span class="line">  &#125;,</span><br><span class="line">  set age(arg)&#123;       <span class="comment">//set(arg)方法必须要有一个形式参数</span></span><br><span class="line">    <span class="comment">//this.age = new Date().getFullYear() - 1984;//会导致无限的递归</span></span><br><span class="line">    <span class="keyword">this</span>._age = arg;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(man.age); <span class="comment">// 32</span></span><br><span class="line">man.age = <span class="number">27</span>;</span><br><span class="line"><span class="built_in">console</span>.log(man.age); <span class="comment">// 27</span></span><br></pre></td></tr></table></figure></p>
<p><code>ECMAScript 5</code>中可以通过<code>Object.getOwnPropertyDescriptor(obj, attr)</code>方法获取指定对象属性的属性描述符。该方法接收两个参数：属性所在的对象和要读取描述符的属性名称。结果返回一个对象。<br><a name="有关对象的其他方法"></a></p>
<h2 id="有关对象的其他方法"><a href="#有关对象的其他方法" class="headerlink" title="有关对象的其他方法"></a><strong>有关对象的其他方法</strong></h2><ul>
<li><code>Object.isExtensible(obj)</code>：查看某个对象是否可扩展（即添加新属性）</li>
<li><code>Object.preventExtentions(obj)</code>：将某个对象设置为不可扩展的，该方法并不会对对象的属性描述符造成影响。</li>
<li><code>Object.seal(obj)</code> 和 <code>Object.isSealed(obj)</code>：若要在设置为不可扩展的基础上设置所有属性的<code>configurable</code>特性为<code>false</code>，则可以使用<code>Object.seal(obj)</code>，然后想查看某个对象是否处于<code>seal</code>状态可以使用<code>Object.isSealed(obj)</code>。</li>
<li><code>Object.freeze(obj)</code> 和 <code>Object.isFrozen(obj)</code> ：若还要在此基础上设置所有属性的<code>writable</code>特性为<code>false</code>，可使用<code>Object.freeze(obj)</code>，查看对象是否处于<code>freeze</code>状态可以使用<code>Object.isFrozen(obj)</code>。</li>
</ul>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/05/02/javascriptSerial-7/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          你所不知道的javascript之BOM
        
      </div>
    </a>
  
  
    <a href="/2016/04/30/javascriptSerial-5/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">你所不知道的javascript之函数</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="javascriptSerial-6" data-title="你所不知道的javascript之对象和继承" data-url="http://yoursite.com/2016/05/01/javascriptSerial-6/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 hbChou
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>